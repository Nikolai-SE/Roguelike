# Roguelike


## Общие сведения о системе

Roguelike — это довольно популярный жанр компьютерных игр, назван в честь игры Rogue, 1980 года выхода. 

* персонаж игрока, способный перемещаться по карте, управляемый с клавиатуры;
* карта обычно генерируется, но для некоторых уровней грузится из файла;
* характеристики персонажа — здоровье, сила атаки;
* у персонажа есть инвентарь, состоящий из вещей, которые он носит с собой;
* вещи из инвентаря можно надеть и снять, надетые вещи влияют на характеристики персонажа;
* вещи изначально находятся на карте, их можно поднять, чтобы добавить в инвентарь;
* снятые вещи находятся в инвентаре, их можно надеть в дальнейшем;
консольная графика, традиционная для этого жанра игр.


## Architectural drivers

## Роли и случаи использования

![](images/Диаграмма%20случаев%20использования.drawio.svg)

### Роли

* *Gamer*
    Игрок. Является единственным пользователем системы в силу синглплеерности проекта.

### Случаи использования

* *Start new game*
    Старт новой игры. Позволяет начать новую игру. Точкой расширения является возможность завершения игровой сессии.

## Описание типичного пользователя

## Композиция (диаграмма компонентов и её текстовое описание)

![](images/Диаграмма%20компонентов.drawio.png)

### Компонентами системы являются 

 * *MainMenu*

    Отвечает за приветствие пользователя при старте приложения. 
    Предлагает пользователю начать игру или закрыть приложение. 

 * Подсистема *"In game state"*



  1. Компонент *GameWorld* содержит логическое представление состояния игры. 
  2. Подсистема *Drawer* отвечает за отрисовку текущего состояния игрового поля и *Head-Up Display (HUD)*.
     * *Camera* отрисовывает изменения на игровом поле.
     * *HUD* отображает актуальное состояние характеристик игрового персонажа и инвентаря.

 * *UserListener*

    Считывает пользовательский ввод, интерпретирует его. Передает результат интерпретации в компоненты MainMenu или подсистему "In game state".


## Логическая структура (диаграмма классов и её текстовое описание)

![Диаграмма классов](images/Диаграмма%20классов.drawio.svg)

### Camera

Класс реализует интерфейс для взаимодействия с отображением игрового мира. Обеспечивается это с пощью взаимодействия с консолью.

Поля:

> `consoleApi`, с пощью которой класс может взаимодействовать с консолью.

Методы:

> `get(Placement) : IDrawable` - по местоположению возвращает объект, который имплементирует интерфейс `IDrawable`.

> `remove(Placement)` - по местоположению удаляет объект с игрового полю.

### HUD

Класс реализует для отображения элеменетов визуального интерфейса игрока, к ним относятся: здоровье, сила атаки, инвентарь.

Поля:

> `personage: Personage`, ссылка на объект персонажа, которым играет пользователь.

Методы:

> `display()` - отображает `HUD` интерфейс на экране пользователя.

### `<<interface>>` IDrawable

Интерфейс содержит минимальный набор методов, которые долны реализовавывать класса для того, чтобы их можно было отображать в игровом мире.

Методы:

> `draw()` - отображает объект класса, который реализует этот интерфейс, на экране пользователя

### AbstractCell

Абстрактный класс ячеек. Ячейки занимают важную роль в игровом мире, так как все объекты построены из ячеек.

Поля:

> `texture: String` - представляет собой структуру, которая будет накладываться на ячеейку

Методы:

> `canBeVisited: bool static` - возвращает статус видимости ячейки. Возвращает `true`, если ячейка может быть видима, `false`, если ячейка не может быть видима.

> `getContent: list<Equipment>` - возвращает список содержимого, которое хранится в ячейке, к нему можно отнести: оружия.


### Cell

Представляет реализацию абстрактного класс ячеек, является элементов игрового мира, способна оторбражаться на экране пользователя, а также взаимодействовать с персонажем.

Поля:

> `content: list<Equipment>` - список вещей, которые содержатся в ячейке.

### Wall

Представляет собой препятствие в игровом мире, которое нельзя пройти персонажу. Является наследником класса `AbstractCell`.

### Placement

Пара координат `X`, `Y`, определяют положение объекта в игровом мире.

> `X, Y : int` - пара координат, местоположение объекта в игровом мире.

### Actor

Абстрактный класс, все классы-наследники представляют собой участников игрового мира. 

Поля:

> `hitPoints: Int` - количество очков здоровья.

> `attackPower: Int` - сила атаки.

Методы:

> `move(Placement)` - двигает персонажа по игровому полю

> `attack(Placement, Int)` - наносит атаку по объекту, который находится по координатам `Placement`

> `getDamage(Int)` - получить урон.

### Enemy

Класс представляет собой вражескую единицу. Объекты этого класса способны отображаться в игровом мире и наность урон по персонажу.

> `enemyStrategy` - стратегия, которая определяет поведения врежеской единицы

### AbstractEnemyStrategy

Стратегия, поведение врежской единицы.

> `doBadThings()` - действие вражеской единицы

### Personage

Класс персонажа, которым управляет игрок.

Поля:

> `inventory: Inventory` - инвентарь персонажа

Методы:

> `take(Equipment eqpmnt)` - подобрать экипировку

> `putOn(Equipment eqpmnt)` - положить экипировку в инвентарь

> `takeOff(Equipment eqpmnt)` - выкинуть экипировку

### Inventory

Класс инвентаря.

> `List<Equipment> used` - список экипировок, которые использует персонаж

> `List<Equipment> unused` - список неиспользуемых экипировок

### Equipment

Абстрактный класс экипировки.

Методы:

> `attackDecorator(Placement p, Int points)` - атака, которая наносится экипировкой.

> `getDamageDecorator(Int)` - получить дамаг, наносимой экипировкой.

### Helmet

Класс, объекты которого представляют собой шлемы, с различными характеристиками. Является наследником `Equipment`.

### Sword

Класс, объекты которого представляют собой мечи, с различными характеристиками. Является наследником `Equipment`.

### SuperEquipment

Класс, объекты которого представляют собой эксклюзивную экипировку, с различными характеристиками. Является наследником `Equipment`.

## Взаимодействия и состояния (диаграммы последовательностей и конечных автоматов и их текстовое описание)

### Диаграмма последовательностей

![Диаграмма последовательностей](images/Диаграмма%20последовательностей.drawio.svg)

* *Run*
    При запуске пользователем приложения создаётся главное меню и отрисовывается.

* *Start New Game*
    При запуске новой игры главное меню прекращает свою жизнь, конструируется игровой мир и отрисовывает себя.

* *Command*
    При вводе пользователем команд игровой мир отвечает на это, фиксируя изменения и отрисовывая себя.

* *Quit*
    При желании пользователя завершить игровую сессию, игровой мир завершает свою жизнь. Конструируется главное меню и отрисовывает себя.

* *Exit*
    При команде завершения приложения, главное меню и приложение завершают свою жизнь.
